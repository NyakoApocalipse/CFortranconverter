/**********************************************************************/
/* File:                                                              */
/* Author:                                                            */
/* This codes is generated by CFortranTranslator                      */
/* CFortranTranslator is published under GPL license                  */
/* refer to https://github.com/CalvinNeo/CFortranTranslator/ for more */
/**********************************************************************/
#include "../for90std/for90std.h" 
#define USE_FORARRAY 
#include "mod_generic_print_utils.h"
#include "type_vars.h"
#include "getwordz.h"
#include "termin.h"
#include "get_iword.h"
#include "get_iword.h"
#include "get_rword.h"
#include "termin.h"
#include "get_iword.h"
#include "write_section_title.h"
#include "space.h"
#include "space.h"
#include "blkcpi.h"
#include "fspace.h"
#include "fspace.h"
#include "getwordz.h"
#include "termin.h"
#include "get_iword.h"
#include "get_iword.h"
#include "get_rword.h"
#include "termin.h"
#include "get_iword.h"
#include "write_section_title.h"
#include "space.h"
#include "space.h"
#include "blkcpi.h"
#include "fspace.h"
#include "fspace.h"
#include "get_iword.h"
#include "write_section_title.h"
#include "space.h"
#include "space.h"
#include "blkcpi.h"
#include "fspace.h"
#include "fspace.h"
struct{
	int32_t _1 = 0;
	int32_t _2 = 0;
	int32_t _3 = 0;
	int32_t _4 = 0;
	int32_t _5 = 0;
	int32_t _6 = 0;
	int32_t _7 = 0;
	int32_t _8 = 0;
	int32_t _9 = 0;
	int32_t _10 = 0;
	int32_t _11 = 0;
	int32_t _12 = 0;

}BLOCK_cohes1;
struct{
	long double _1 = 0.0;

}BLOCK_delam_dtmin;
struct{
	forstring _1 = "                                                                                ";
	int32_t _2 = 0;
	int32_t _3 = 0;

}BLOCK_freeinput;
struct{
	bool _1;

}BLOCK_shorthsp;
void cohesin();
void cohesin1();
void cohesin4(int && linkc, int && inum);
void cohesin()
{
	static double blank = 0.0;
	long double & deltsmin = BLOCK_delam_dtmin._1;
	bool dkey;
	int32_t i = 0;
	int32_t & iccohdat = BLOCK_cohes1._7;
	int32_t & icdamg = BLOCK_cohes1._9;
	int32_t & icfailc = BLOCK_cohes1._10;
	int32_t & icinum = BLOCK_cohes1._12;
	int32_t & icixch = BLOCK_cohes1._8;
	int32_t & iclinkc = BLOCK_cohes1._6;
	int32_t & icnhexc = BLOCK_cohes1._11;
	int32_t & icnmid = BLOCK_cohes1._5;
	int32_t & icolumn = BLOCK_freeinput._3;
	int32_t & icpropc = BLOCK_cohes1._4;
	farray<int> inum {};
	int32_t * ipitmp = nullptr;
	int32_t * ipnspan = nullptr;
	int32_t iss = 0;
	farray<int32_t> itmp {};
	int32_t j = 0;
	int32_t k = 0;
	forstring key = "                                                                                ";
	int32_t & lcount = BLOCK_freeinput._2;
	farray<int> linkc {};
	int32_t max_matn = 0;
	int32_t min_matn = 0;
	int32_t moff = 0;
	int32_t mspan = 0;
	forstring mssg = "                                                                                ";
	int32_t & nccons = BLOCK_cohes1._3;
	int32_t & ncohd = BLOCK_cohes1._2;
	farray<int32_t> nspan {};
	int32_t & numcoh = BLOCK_cohes1._1;
	forstring option = "                                                                                ";
	forstring & txts = BLOCK_freeinput._1;
	bool & vhsp = BLOCK_shorthsp._1;
	double zero = 0.0;
	
	
	
	
	
	/*c*/
	/*c Read in cohesive data and elements.*/
	/*c Write and initizialize data as necessary.*/
	/*c*/
	/*!*/
	/*!*/
	/*!*/
	/*c*/
	/*c delamination common block*/
	/*c*/
	
	/*c*/
	
	/*c*/
	
	/*c*/
	
	
	
	/*c*/
	/*c Local variables*/
	/*c*/
	
	/*c*/
	
	/*c*/
	
	blank = SS(" ");
	
	
	
	
	
	
	
	
	
	
	
	
	
	deltsmin = zero;
	/*c*/
	/*c*/
	/*c   To read in the next variable use:*/
	/*c      call get_iword(ivar)         for integers*/
	/*c      call get_rword(rvar)         for reals*/
	/*c      call get_fword(fvar)         for file names*/
	/*c   To read data from the keyword string use:*/
	/*c      call get_data(key,0,rdum,idum)  for integer*/
	/*c      call get_data(key,1,rdum,idum)  for real*/
	/*c    data is returned as rdum or idum*/
	/*c*/
	/*c Get delam defintions from keywords:*/
	/*c*/
	/*! entry cohesin1( )*/
	
	
	icolumn = 81;
	/*c*/
	/*c Prepare to start reading*/
	option = blank;
	dkey = false;
	
	LABEL_cohesin_5:
	getwordz(INOUT(key));
	/*c*/
	
	if (forslice(key, {{1, 8}}) == SS("cohesive")) {
		option = blank;
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 9}}) == SS("materials") || forslice(key, {{1, 4}}) == SS("defi")){
		get_iword(INOUT(ncohd));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 8}}) == SS("elements") || forslice(key, {{1, 4}}) == SS("elem")){
		get_iword(INOUT(numcoh));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 5}}) == SS("tsmin")){
		get_rword(INOUT(deltsmin));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 7}}) == SS("endfree")) {
		if (ncohd * numcoh == 0) {
			mssg = SS("error in COHESIVE: # of elements or materials is zero");
			/*c*/
			termin(INOUT(txts), INOUT(mssg), INOUT(lcount), INOUT(1));
			
		}
		nop();
		
		
	}else {
		mssg = SS(" error in COHESIVE control cards: unknown option") + SS(" or data");
		/*c*/
		termin(INOUT(txts), INOUT(mssg), INOUT(lcount), INOUT(1));
		
		
	}
	/*c*/
	
	goto LABEL_cohesin_5;
	/*c*/
	
	
	
	
	
	
	
	
	icolumn = 81;
	/*c*/
	/*c -----------------------------------------------------------------*/
	/*c*/
	/*c Read in cohesive definitions*/
	/*c*/
	/*! entry cohesin4(linkc,inum)*/
	/*c*/
	/*c Prepare to start reading*/
	for(i = 1; i <= numcoh; i += 1){
		for(j = 1; j <= 10; j += 1){
			get_iword(INOUT(linkc(INOUT(j), INOUT(i))));
			
		}
		nop();
		
	}
	nop();
	
	
	write_section_title(INOUT(SS("Cohesive Elements")));
	/*c*/
	/*c Write out cohesive definitions*/
	forwrite(get_file(13), IOFormat{"\n Data defined %8d cohesive elements\n\n\n", 0, 41}, numcoh);
	if (vhsp) {
		forwrite(get_file(13), IOFormat{"   #      mat    node 1  node 2  node 3  node 4  node 5  node 6  node 7  node 8\n", 0, 79} );
		for(i = 1; i <= numcoh; i += 1){
			forwrite(get_file(13), IOFormat{"%8d%8d%8d%8d%8d%8d%8d%8d%8d%8d\n", 0, 30}, make_implieddo({1}, {10}, [&](const fsize_t * current_j){
				return [&](fsize_t j){
					return linkc(INOUT(j), INOUT(i));
				}(current_j[0]);
			}));
			
		}
		nop();
		
	}
	
	
	min_matn = 1000000;
	/*c*/
	/*c Redo element connectivity - bunch material numbers together*/
	max_matn = 0;
	for(i = 1; i <= numcoh; i += 1){
		min_matn = min_n(min_matn, linkc(INOUT(2), INOUT(i)));
		max_matn = max_n(max_matn, linkc(INOUT(2), INOUT(i)));
		
	}
	nop();
	mspan = max_matn - min_matn + 1;
	moff = min_matn - 1;
	space(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*!span array*/
	
	
	for(i = 1; i <= numcoh; i += 1){
		nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) = nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) + 1;
		/*c*/
		/*c count how many of each material type there are*/
		
	}
	nop();
	
	
	space(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*c*/
	/*c move elements around for vectorization*/
	/*!temporary space for linkd*/
	iss = 1;
	blkcpi(INOUT(linkc), INOUT(itmp), INOUT(10 * numcoh));
	for(j = min_matn; j <= max_matn; j += 1){
		if (nspan(INOUT(j - moff)) > 0) {
			for(i = 1; i <= numcoh; i += 1){
				if (itmp(INOUT(2), INOUT(i)) == j) {
					for(k = 1; k <= 10; k += 1){
						linkc(INOUT(k), INOUT(iss)) = itmp(INOUT(k), INOUT(i));
						
					}
					nop();
					inum(INOUT(itmp(INOUT(1), INOUT(i)))) = iss;
					/*!inverse re-order array*/
					iss = iss + 1;
					
				}
				
			}
			nop();
			
		}
		
	}
	nop();
	
	
	fspace(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*c*/
	/*c free temp space*/
	/*!span array*/
	fspace(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*!temporary space for linkd*/
	
	nop();
	/*c*/
	
	return ;
}

void cohesin1()
{
	double blank = 0.0;
	double deltsmin = 0.0;
	double dkey = 0.0;
	int i = 0;
	int icolumn = 0;
	int ipitmp = 0;
	int ipnspan = 0;
	int iss = 0;
	int itmp = 0;
	int j = 0;
	int k = 0;
	int key = 0;
	int lcount = 0;
	int linkc = 0;
	int max_matn = 0;
	int min_matn = 0;
	int moff = 0;
	int mspan = 0;
	int mssg = 0;
	int ncohd = 0;
	int numcoh = 0;
	double option = 0.0;
	double txts = 0.0;
	double vhsp = 0.0;
	double zero = 0.0;
	deltsmin = zero;
	
	
	icolumn = 81;
	/*c*/
	/*c Prepare to start reading*/
	option = blank;
	dkey = false;
	
	LABEL_cohesin1_5:
	getwordz(INOUT(key));
	/*c*/
	
	if (forslice(key, {{1, 8}}) == SS("cohesive")) {
		option = blank;
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 9}}) == SS("materials") || forslice(key, {{1, 4}}) == SS("defi")){
		get_iword(INOUT(ncohd));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 8}}) == SS("elements") || forslice(key, {{1, 4}}) == SS("elem")){
		get_iword(INOUT(numcoh));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 5}}) == SS("tsmin")){
		get_rword(INOUT(deltsmin));
		/*c*/
		
		
	}
	else if(forslice(key, {{1, 7}}) == SS("endfree")) {
		if (ncohd * numcoh == 0) {
			mssg = SS("error in COHESIVE: # of elements or materials is zero");
			/*c*/
			termin(INOUT(txts), INOUT(mssg), INOUT(lcount), INOUT(1));
			
		}
		nop();
		
		
	}else {
		mssg = SS(" error in COHESIVE control cards: unknown option") + SS(" or data");
		/*c*/
		termin(INOUT(txts), INOUT(mssg), INOUT(lcount), INOUT(1));
		
		
	}
	/*c*/
	
	goto LABEL_cohesin1_5;
	/*c*/
	
	
	
	
	
	
	
	icolumn = 81;
	/*c*/
	/*c -----------------------------------------------------------------*/
	/*c*/
	/*c Read in cohesive definitions*/
	/*c*/
	/*c*/
	/*c Prepare to start reading*/
	for(i = 1; i <= numcoh; i += 1){
		for(j = 1; j <= 10; j += 1){
			get_iword(INOUT(linkc(INOUT(j), INOUT(i))));
			
		}
		nop();
		
	}
	nop();
	
	
	write_section_title(INOUT(SS("Cohesive Elements")));
	/*c*/
	/*c Write out cohesive definitions*/
	forwrite(get_file(13), IOFormat{"\n Data defined %8d cohesive elements\n\n\n", 0, 41}, numcoh);
	if (vhsp) {
		forwrite(get_file(13), IOFormat{"   #      mat    node 1  node 2  node 3  node 4  node 5  node 6  node 7  node 8\n", 0, 79} );
		for(i = 1; i <= numcoh; i += 1){
			forwrite(get_file(13), IOFormat{"%8d%8d%8d%8d%8d%8d%8d%8d%8d%8d\n", 0, 30}, make_implieddo({1}, {10}, [&](const fsize_t * current_j){
				return [&](fsize_t j){
					return linkc(INOUT(j), INOUT(i));
				}(current_j[0]);
			}));
			
		}
		nop();
		
	}
	
	
	min_matn = 1000000;
	/*c*/
	/*c Redo element connectivity - bunch material numbers together*/
	max_matn = 0;
	for(i = 1; i <= numcoh; i += 1){
		min_matn = min_n(min_matn, linkc(INOUT(2), INOUT(i)));
		max_matn = max_n(max_matn, linkc(INOUT(2), INOUT(i)));
		
	}
	nop();
	mspan = max_matn - min_matn + 1;
	moff = min_matn - 1;
	space(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*!span array*/
	
	
	for(i = 1; i <= numcoh; i += 1){
		nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) = nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) + 1;
		/*c*/
		/*c count how many of each material type there are*/
		
	}
	nop();
	
	
	space(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*c*/
	/*c move elements around for vectorization*/
	/*!temporary space for linkd*/
	iss = 1;
	blkcpi(INOUT(linkc), INOUT(itmp), INOUT(10 * numcoh));
	for(j = min_matn; j <= max_matn; j += 1){
		if (nspan(INOUT(j - moff)) > 0) {
			for(i = 1; i <= numcoh; i += 1){
				if (itmp(INOUT(2), INOUT(i)) == j) {
					for(k = 1; k <= 10; k += 1){
						linkc(INOUT(k), INOUT(iss)) = itmp(INOUT(k), INOUT(i));
						
					}
					nop();
					inum(INOUT(itmp(INOUT(1), INOUT(i)))) = iss;
					/*!inverse re-order array*/
					iss = iss + 1;
					
				}
				
			}
			nop();
			
		}
		
	}
	nop();
	
	
	fspace(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*c*/
	/*c free temp space*/
	/*!span array*/
	fspace(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*!temporary space for linkd*/
	
	nop();
	/*c*/
	
	return ;
}

void cohesin4(int && linkc, int && inum)
{
	int i = 0;
	int icolumn = 0;
	int ipitmp = 0;
	int ipnspan = 0;
	int iss = 0;
	int itmp = 0;
	int j = 0;
	int k = 0;
	int max_matn = 0;
	int min_matn = 0;
	int moff = 0;
	int mspan = 0;
	int numcoh = 0;
	double vhsp = 0.0;
	icolumn = 81;
	/*c*/
	/*c Prepare to start reading*/
	for(i = 1; i <= numcoh; i += 1){
		for(j = 1; j <= 10; j += 1){
			get_iword(INOUT(linkc(INOUT(j), INOUT(i))));
			
		}
		nop();
		
	}
	nop();
	
	
	write_section_title(INOUT(SS("Cohesive Elements")));
	/*c*/
	/*c Write out cohesive definitions*/
	forwrite(get_file(13), IOFormat{"\n Data defined %8d cohesive elements\n\n\n", 0, 41}, numcoh);
	if (vhsp) {
		forwrite(get_file(13), IOFormat{"   #      mat    node 1  node 2  node 3  node 4  node 5  node 6  node 7  node 8\n", 0, 79} );
		for(i = 1; i <= numcoh; i += 1){
			forwrite(get_file(13), IOFormat{"%8d%8d%8d%8d%8d%8d%8d%8d%8d%8d\n", 0, 30}, make_implieddo({1}, {10}, [&](const fsize_t * current_j){
				return [&](fsize_t j){
					return linkc(INOUT(j), INOUT(i));
				}(current_j[0]);
			}));
			
		}
		nop();
		
	}
	
	
	min_matn = 1000000;
	/*c*/
	/*c Redo element connectivity - bunch material numbers together*/
	max_matn = 0;
	for(i = 1; i <= numcoh; i += 1){
		min_matn = min_n(min_matn, linkc(INOUT(2), INOUT(i)));
		max_matn = max_n(max_matn, linkc(INOUT(2), INOUT(i)));
		
	}
	nop();
	mspan = max_matn - min_matn + 1;
	moff = min_matn - 1;
	space(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*!span array*/
	
	
	for(i = 1; i <= numcoh; i += 1){
		nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) = nspan(INOUT(linkc(INOUT(2), INOUT(i)) - moff)) + 1;
		/*c*/
		/*c count how many of each material type there are*/
		
	}
	nop();
	
	
	space(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*c*/
	/*c move elements around for vectorization*/
	/*!temporary space for linkd*/
	iss = 1;
	blkcpi(INOUT(linkc), INOUT(itmp), INOUT(10 * numcoh));
	for(j = min_matn; j <= max_matn; j += 1){
		if (nspan(INOUT(j - moff)) > 0) {
			for(i = 1; i <= numcoh; i += 1){
				if (itmp(INOUT(2), INOUT(i)) == j) {
					for(k = 1; k <= 10; k += 1){
						linkc(INOUT(k), INOUT(iss)) = itmp(INOUT(k), INOUT(i));
						
					}
					nop();
					inum(INOUT(itmp(INOUT(1), INOUT(i)))) = iss;
					/*!inverse re-order array*/
					iss = iss + 1;
					
				}
				
			}
			nop();
			
		}
		
	}
	nop();
	
	
	fspace(INOUT(mspan), INOUT(ipnspan), INOUT(0));
	/*c*/
	/*c free temp space*/
	/*!span array*/
	fspace(INOUT(numcoh * 10), INOUT(ipitmp), INOUT(0));
	/*!temporary space for linkd*/
	
	nop();
	/*c*/
	
	return ;
}


